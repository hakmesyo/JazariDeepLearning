/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package utils;

import jazari.BackEnd;
import jazari.DataSource;
import jazari.ProgrammingLanguage;

/**
 *
 * @author BAP1
 */
public class FactoryScripts {

    private final static String strPythonLibrary
            = "#Temporary Script generated by Jazari Deep Learning Framework\n"
            + "import tensorflow.keras\n"
            + "from PIL import Image\n"
            + "import numpy as np\n"
            + "import os\n"
            + "import matplotlib.pyplot as plt\n"
            + "from keras.optimizers import Adam,Adadelta\n"
            + "import timeit\n"
            + "import time\n"
            + "import websocket\n"
            + "import cv2\n"
            + "ws=websocket.WebSocket();\n"
            + "ws.connect('ws://127.0.0.1:8887')\n";

    public static String generateScriptFile(ProgrammingLanguage programming_language, BackEnd back_end, DataSource data_source, String model_path, String[] classLabels) {
        String str = "";
        String ek ="class_names = [";
        for (int i = 0; i < classLabels.length; i++) {
            ek+="'"+classLabels[i]+"',";
        }
        ek=ek.substring(0,ek.length()-1);
        ek=ek+"]\n";
        if (back_end == BackEnd.CPU) {
            if (data_source == DataSource.CAMERA) {
                if (programming_language == ProgrammingLanguage.PYTHON) {
                    str = strPythonLibrary
                            + ek+
                            "# Load the model\n"
                            //+ "model = tensorflow.keras.models.load_model(r'C:\\python_data\\models\\keras_model_pistachio.h5')\n"
                            + "model = tensorflow.keras.models.load_model(r'"+model_path+"')\n"
                            + "data = np.ndarray(shape=(1, 224, 224, 3), dtype=np.float32)\n"
                            + "def open_camera():\n"
                            + "    global nTotal;\n"
                            + "    global nOpenSuccess;\n"
                            + "    global nClosedSuccess;\n"
                            + "    global acc;\n"
                            + "    x='open'\n"
                            + "    capture=cv2.VideoCapture(0)\n"
                            + "    while(True):\n"
                            + "        start = timeit.default_timer()\n"
                            + "        ret, frame = capture.read()\n"
                            + "        cv2.imshow('video', frame)\n"
                            + "        image = np.resize(frame,(224, 224,3))\n"
                            + "        image_array = np.asarray(image)\n"
                            + "        normalized_image_array = (image_array.astype(np.float32) / 127.0) - 1\n"
                            + "        # Load the image into the array\n"
                            + "        data[0] = normalized_image_array\n"
                            + "        # run the inference\n"
                            + "        prediction = model.predict(data)\n"
                            + "        ws.send('class:'+class_names[np.argmax(prediction)])\n"
                            + "        stop = timeit.default_timer()\n"
                            + "        if cv2.waitKey(2) == 27:\n"
                            + "            break\n"
                            + "    capture.release()\n"
                            + "    cv2.destroyAllWindows()\n"
                            + "open_camera()\n";
                    FactoryUtils.writeToFile(FactoryUtils.currDir + "\\tmp.py", str);
                    return FactoryUtils.currDir + "\\tmp.py";
                }
            }
        }
        return null;
    }

}
/*
                            "# Load the model\n"
                            + "#model = tensorflow.keras.models.load_model('tm_keras_model_big_ds.h5')\n"
                            + "#model = tensorflow.keras.models.load_model('keras_model_epoch200.h5')\n"
                            + "#model = tensorflow.keras.models.load_model('data_augment_model.h5')\n"
                            + "#model = tensorflow.keras.models.load_model('vgg16_model_big_ds.h5')\n"
                            + "#model = tensorflow.keras.models.load_model('vgg16_1000_ds.h5')\n"
                            + "#model = tensorflow.keras.models.load_model('cnn.h5')\n"
                            + "model = tensorflow.keras.models.load_model(r'C:\\python_data\\models\\keras_model_pistachio.h5')\n"
                            + "#model = tensorflow.keras.models.load_model(r'C:\\python_data\\models\\cuneyt_mobilenet.h5')\n"
                            + "#model.summary()\n"
                            + "# Create the array of the right shape to feed into the keras model\n"
                            + "# The 'length' or number of images you can put into the array is\n"
                            + "# determined by the first position in the shape tuple, in this case 1.\n"
                            + "data = np.ndarray(shape=(1, 224, 224, 3), dtype=np.float32)\n"
                            + "# Replace this with the path to your image\n"
                            + "nOpenSuccess=0\n"
                            + "nClosedSuccess=0\n"
                            + "nTotal=0;\n"
                            + "acc=0.0\n"
                            + "#path=r'C:\\python_data\\dataset\\pistachio\\snapshots'\n"
                            + "#for imge in os.listdir(path):\n"
                            + "#        image = Image.open(os.path.join(path,imge))\n"
                            + "#        # Make sure to resize all images to 224, 224 otherwise they won't fit in the array\n"
                            + "#        image = image.resize((224, 224))\n"
                            + "#        plt.imshow(image)\n"
                            + "#        plt.show()\n"
                            + "#        image_array = np.asarray(image)\n"
                            + "#        # Normalize the image\n"
                            + "#        normalized_image_array = (image_array.astype(np.float32) / 255.0)\n"
                            + "##        normalized_image_array = (image_array.astype(np.float32) / 127.0) - 1\n"
                            + "#        # Load the image into the array\n"
                            + "#        data[0] = normalized_image_array\n"
                            + "#        # run the inference\n"
                            + "#        prediction = model.predict(data)\n"
                            + "#        nTotal+=1\n"
                            + "#        print('acc',acc,' class:',class_names[np.argmax(prediction)])\n"
                            + "#for x in class_names:\n"
                            + "#    path=os.path.join(r'C:\\python_data\\dataset\\pistachio\\teachable_machine\\test',x)\n"
                            + "#    for imge in os.listdir(path):\n"
                            + "#        image = Image.open(os.path.join(path,imge))\n"
                            + "#        # Make sure to resize all images to 224, 224 otherwise they won't fit in the array\n"
                            + "#        image = image.resize((224, 224))\n"
                            + "##        plt.imshow(image)\n"
                            + "##        plt.show()\n"
                            + "#        image_array = np.asarray(image)\n"
                            + "#        # Normalize the image\n"
                            + "#        normalized_image_array = (image_array.astype(np.float32) / 127.0) - 1\n"
                            + "##        normalized_image_array = (image_array.astype(np.float32) / 255.0)\n"
                            + "#        # Load the image into the array\n"
                            + "#        data[0] = normalized_image_array \n"
                            + "#        # run the inference\n"
                            + "#        start = timeit.default_timer()\n"
                            + "#        prediction = model.predict(data)\n"
                            + "#        stop = timeit.default_timer()\n"
                            + "#        nTotal+=1\n"
                            + "#        if x=='open' and np.argmax(prediction)==1:\n"
                            + "#            nOpenSuccess+=1\n"
                            + "#        if x=='closed' and np.argmax(prediction)==0:\n"
                            + "#            nClosedSuccess+=1\n"
                            + "#        acc=(nOpenSuccess+nClosedSuccess)*1.0/nTotal\n"
                            + "#        print('acc',acc,' class:',class_names[np.argmax(prediction)],' elapsed time:', (stop-start))\n"
                            + "#        ws.send('class:'+class_names[np.argmax(prediction)])\n"
                            + "def open_camera():\n"
                            + "    global nTotal;\n"
                            + "    global nOpenSuccess;\n"
                            + "    global nClosedSuccess;\n"
                            + "    global acc;\n"
                            + "    x='open'\n"
                            + "    capture=cv2.VideoCapture(0)\n"
                            + "    while(True):\n"
                            + "        start = timeit.default_timer()\n"
                            + "        ret, frame = capture.read()\n"
                            + "        cv2.imshow('video', frame)\n"
                            + "        image = np.resize(frame,(224, 224,3))\n"
                            + "        image_array = np.asarray(image)\n"
                            + "        normalized_image_array = (image_array.astype(np.float32) / 127.0) - 1\n"
                            + "        # Load the image into the array\n"
                            + "        data[0] = normalized_image_array\n"
                            + "        # run the inference\n"
                            + "        prediction = model.predict(data)\n"
                            + "        nTotal+=1\n"
                            + "        if x=='open' and np.argmax(prediction)==1:\n"
                            + "            nOpenSuccess+=1\n"
                            + "        if x=='closed' and np.argmax(prediction)==0:\n"
                            + "            nClosedSuccess+=1\n"
                            + "        acc=(nOpenSuccess+nClosedSuccess)*1.0/nTotal\n"
                            + "        ws.send('class:'+class_names[np.argmax(prediction)])\n"
                            + "        stop = timeit.default_timer()\n"
                            + "        #print('acc',acc,' class:',class_names[np.argmax(prediction)],' elapsed time:', (stop-start)*1000)\n"
                            + "        if cv2.waitKey(2) == 27:\n"
                            + "            break\n"
                            + "    capture.release()\n"
                            + "    cv2.destroyAllWindows()\n"
                            + "open_camera()\n"
                            + "print('overall accuracy:',acc)\n"
                            + "print('hit open :',nOpenSuccess)\n"
                            + "print('hit closed :',nClosedSuccess)\n"
                            + "print('#samples:',nTotal)";
*/